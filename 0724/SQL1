DECLARE
BEGIN
    FOR I IN 0..10 LOOP
        IF MOD(I, 3) = 0 THEN
            DBMS_OUTPUT.PUT_LINE('출력 : ' || I);
        END IF;
    END LOOP;
END;
/

DECLARE
BEGIN
    FOR I IN REVERSE 0..4 LOOP
        DBMS_OUTPUT.PUT_LINE('현재 I의 값 : ' || I);
    END LOOP;
END;
/

--16-21 FOR LOOP 안에 CINTINUE
BEGIN
    FOR I IN 0..4 LOOP
        CONTINUE WHEN MOD(I,2) = 1;
        DBMS_OUTPUT.PUT_LINE(I);
    END LOOP;
END;
/

--17-1 레코드를 정의해서 사용하기
DECLARE
    TYPE REC_DEPT IS RECORD(
        deptno NUMBER(2) NOT NULL := 99,
        dname DEPT.DNAME%TYPE,
        loc DEPT.LOC%TYPE
    );
    dept_rec REC_DEPT;
BEGIN
    dept_rec.deptno := 99;
    dept_rec.dname := 'DATABASE';
    dept_rec.loc := 'SEOUL';
    DBMS_OUTPUT.PUT_LINE(dept_rec.deptno);
    DBMS_OUTPUT.PUT_LINE(dept_rec.dname);
    DBMS_OUTPUT.PUT_LINE(dept_rec.loc);
END;
/

--17-2 DEPT_RECORD
CREATE TABLE DEPT_RECORD
AS SELECT * FROM DEPT;

SELECT * FROM DEPT_RECORD;
COMMIT;

--17-2
DECLARE
    TYPE REC_DEPT IS RECORD(
        deptno NUMBER(2) NOT NULL := 99,
        dname DEPT.DNAME%TYPE,
        loc DEPT.LOC%TYPE
    );
    dept_rec REC_DEPT;  --객체선언
BEGIN
    dept_rec.deptno := 99;
    dept_rec.dname := 'DATABASE';
    dept_rec.loc := 'SEOUL';
    
    INSERT INTO DEPT_RECORD
    VALUES dept_rec;
END;
/

--17-3
DECLARE
    TYPE REC_DEPT IS RECORD(
        deptno NUMBER(2) NOT NULL := 10,
        dname DEPT.DNAME%TYPE,
        loc DEPT.LOC%TYPE
    );
    deptrecord DEPTREC;  --객체선언
BEGIN
    deptrecord.deptno := 88;
    deptrecord.dname := '연구';
    deptrecord.loc := '구미';
    
    INSERT INTO DEPT_RECORD
    VALUES deptrecord;
END;
/

DESC DEPT_RECORD;

DECLARE
    TYPE REC_DEPT IS RECORD(
        deptno NUMBER(2) NOT NULL := 0,
        dname DEPT.DNAME%TYPE,
        loc DEPT.LOC%TYPE
    );
    deptrecord DEPTREC;  --객체선언
BEGIN
    deptrecord.deptno := 50;
    deptrecord.dname := 'DB';
    deptrecord.loc := 'ANDONG';
    
    UPDATE DEPT_RECORD
    SET ROW = deptrecord
    WHERE DEPTNO = 99;
END;
/

-- 사용자 사전
SELECT * FROM DICT;
SELECT COUNT(*) FROM DICT;
SELECT * FROM DICTIONARY;
SELECT COUNT(*) FROM DICTIONARY;

--사용자 산전(USER_%)
SELECT TABLE_NAME FROM USER_TABLES
ORDER BY TABLE_NAME;

--ALL_%
SELECT * FROM ALL_TABLES;
SELECT OWNER, TABLE_NAME FROM ALL_TABLES;

--DBA_%
SELECT * FROM DBA_TABLES;
SELECT OWNER, TABLE_NAME FROM DBA_TABLES;
SELECT COUNT(*) FROM DBA_TABLES;

SELECT * FROM DBA_USERS
WHERE username = 'SCOTT';

--인덱스 확인
SELECT * FROM USER_INDEXES;

SELECT * FROM USER_IND_COLUMNS;

--INDEX 만들기
CREATE INDEX IDX_EMP_SAL ON EMP(SAL);
SELECT SAL FROM EMP;
--INDEX 삭제
DROP INDEX IDX_EMP_SAL;

--VIEW
SELECT * FROM VW_EMP20;

SELECT * FROM (SELECT EMPNO, ENAME, SAL FROM EMP WHERE DEPTNO = 20);
--SCOTT 계정에 VIEW를 만드는 권한을 줍시다.!!
GRANT CREATE VIEW TO SCOTT;
--뷰 만들기
CREATE VIEW VW_EMP20;
AS (SELECT EMPNO, ENAME, JOB, DEPTNO
    FROM EMP
    WHERE DEPTNO = 20);
    
--뷰 확인
SELECT * FROM USER_VIWS;
--삭제
DROP VIWE VM_EMP20;

--동의어 (SYNONYM)
GRANT CREATE SYNONYM TO SCOTT;

GRANT CREATE PUBLIC SYNONYM TO SCOTT;

--동의어
CREATE SYNONYM E FOR EMP;

SELECT * FROM E;
DROP SYNONYM E;

--18-1 단일행 데이터 저장하기
DECLARE
    V_DEPT_ROW      DEPT%ROWTYPE;
BEGIN
    SELECT DEPTNO, DNAME, LOC INTO V_DEPT_ROW FROM DEPT
    WHERE DEPTNO = 40;
    DBMS_OUTPUT.PUT_LINE(V_DEPT_ROW.DEPTNO);
    DBMS_OUTPUT.PUT_LINE(V_DEPT_ROW.DNAME);
    DBMS_OUTPUT.PUT_LINE(V_DEPT_ROW.LOC);
END;
/

--18-2 단일행 데이터 저장하는 커서 사용
DECLARE
    V_DEPT_ROW      DEPT%ROWTYPE;
    --명시적 커서 선언
    CURSOR c1 IS
        SELECT DEPTNO, DNAME, LOC FROM DEPT WERE DEPTNO = 40;
BEGIN
    --커서사용?  커서열기 OPEN
    OPEN c1;
    --데이터 가공
    FETCH c1 INTO V_DEPT_ROW;
    
    DBMS_OUTPUT.PUT_LINE(V_DEPT_ROW.DEPTNO);
    DBMS_OUTPUT.PUT_LINE(V_DEPT_ROW.DNAME);
    DBMS_OUTPUT.PUT_LINE(V_DEPT_ROW.LOC);
    
    --커서닫기 리소스 반환
    CLOSE c1;
END;
/
